//          Copyright (C) 2022 PsiMasTho (1cbb875@gmail.com)
// Distributed under the Boost Software License, Version 1.0.
//    (See accompanying file LICENSE.txt or copy at
//          https://www.boost.org/LICENSE_1_0.txt)

%scanner log_lexer.h
%scanner-class-name log_lexer
%parsefun-source log_parser_base.cc
%token-class log_tokens
%token-path log_tokens.h

%baseclass-preinclude log_parser_base_preinclude.h

%token  IDENT
        NEWLINE
        DATE
        IDENT_VALUE_PAIR

%polymorphic STRING:              std::string;
             STRING_PAIR:         std::pair<std::string, std::string>;
             LOG_DATE:            log_date;
             SPARSE_ARRAY_STRING: std::optional<sparse_array<std::string>>;

%type <STRING_PAIR>         ident_value_pair;
%type <SPARSE_ARRAY_STRING> ident_value_pair_list;
%type <STRING>              variable;
%type <STRING>              identifier;
%type <LOG_DATE>            date;

%%

input:
    // empty
|
    input statement
;

// todo: the extra production rules for EOF are hacky but work for now
statement:
    date NEWLINE
    {
        m_ctx.set_date($1);
    }
|
    date EOF
    {
        m_ctx.set_date($1);
        m_ctx.at_eof();
        ACCEPT();
    }
|
    variable
    {
        m_ctx.set_active_variable_or_err($1);
    }
|
    ident_value_pair_list NEWLINE
    {
        m_ctx.create_entry_or_err($1.value());
    }
|
    ident_value_pair_list EOF
    {
        m_ctx.create_entry_or_err($1.value());
        m_ctx.at_eof();
        ACCEPT();
    }
|
    NEWLINE
|
    EOF
    {
        m_ctx.at_eof();
        ACCEPT();
    }
;

ident_value_pair_list:
    ident_value_pair ';'
    {
        $$ = m_ctx.make_ident_value_pair_list_or_err($1);
    }
|
    ident_value_pair_list ident_value_pair ';'
    {
        m_ctx.update_ident_value_pair_list_or_err($1.value(), $2);
        $$ = $1;
    }
;

variable:
    identifier ':'
    {
        $$ = $1;
    }
;

identifier:
    IDENT
    {
        std::string const val{m_lexer.matched().data(), m_lexer.matched().size()};
        $$ = std::move(val);
    }
;

date:
    DATE
    {
        std::string const val{m_lexer.matched().data(), m_lexer.matched().size()};
        $$ = log_date{val};
    }
;

ident_value_pair:
    IDENT_VALUE_PAIR
    {
        std::string val{m_lexer.matched().data(), m_lexer.matched().size()};

        std::size_t const split = strchr(val.data(), ' ') - val.data();
        std::string const s1 = val.substr(0, split);
        std::string s2 = val.substr(split + 1);

        // trim s2 lhs
        std::size_t const s2_lhs = s2.find_first_not_of(' ');
        if (s2_lhs != std::string::npos)
            s2.erase(0, s2_lhs);
        
        // trim s2 rhs
        std::size_t const s2_rhs = s2.find_last_not_of(' ');
        if (s2_rhs != std::string::npos)
            s2.erase(s2_rhs + 1);

        $$ = make_pair(s1, s2);
    }
;