//          Copyright (C) 2022 PsiMasTho (1cbb875@gmail.com)
// Distributed under the Boost Software License, Version 1.0.
//    (See accompanying file LICENSE.txt or copy at
//          https://www.boost.org/LICENSE_1_0.txt)

%scanner lexer.h
%scanner-class-name lexer
%parsefun-source log_parser_base.cc

%baseclass-preinclude log_parser_base_preinclude.h

// Note: We have to list *ALL* of the tokens here even if we don't use them
%token  DECL_VAR  // unused
        IDENT
        DECL_ATTR // unused
        NEWLINE
        DATE
        REGEX     // unused
        ATTR_VALUE

%polymorphic STRING:              std::string;
             STRING_PAIR:         std::pair<std::string, std::string>;
             LOG_DATE:            log_date;
             SPARSE_ARRAY_STRING: std::optional<sparse_array<std::string>>;

%type <STRING_PAIR>         attr_value_pair;
%type <SPARSE_ARRAY_STRING> attr_value_arr;
%type <STRING>              variable;
%type <STRING>              identifier;
%type <LOG_DATE>            date;
%type <STRING>              attr_value;

%%

input:
    // empty
|
    input statement
;

// todo: the extra production rules for EOF are hacky but work for now
statement:
    date NEWLINE
    {
        m_ctx.set_date($1);
    }
|
    date EOF
    {
        m_ctx.set_date($1);
        m_ctx.at_eof();
        ACCEPT();
    }
|
    variable NEWLINE
    {
        m_ctx.set_active_variable_or_err($1);
    }
|
    variable EOF
    {
        m_ctx.set_active_variable_or_err($1);
        m_ctx.at_eof();
        ACCEPT();
    }
|
    attr_value_arr NEWLINE
    {
        m_ctx.create_entry_or_err($1.value());
    }
|
    attr_value_arr EOF
    {
        m_ctx.create_entry_or_err($1.value());
        m_ctx.at_eof();
        ACCEPT();
    }
|
    NEWLINE
|
    EOF
    {
        m_ctx.at_eof();
        ACCEPT();
    }
;

attr_value_pair:
    identifier attr_value ';'
    {
        $$ = make_pair($1, $2);
    }
;

attr_value_arr:
    attr_value_pair
    {
        $$ = m_ctx.make_attr_value_arr_or_err($1);
    }
|
    attr_value_arr attr_value_pair
    {
        m_ctx.update_attr_value_arr_or_err($1.value(), $2);
        $$ = $1;
    }
;

variable:
    identifier ':'
    {
        $$ = $1;
    }
;

identifier:
    IDENT
    {
        $$ = m_lexer.matched();
    }
;

date:
    DATE
    {
        $$ = log_date{m_lexer.matched()};
    }
;

attr_value:
    ATTR_VALUE
    {
        $$ = m_lexer.matched();
    }
;