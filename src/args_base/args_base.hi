template <typename Derived>
template <typename Type>
void ArgsBase<Derived>::registerArg(std::optional<Type>& optVar, std::string const &optName)
{
        // Make a lambda that uses the conversion function to assign the arg directly
    BoundCvtFunc_t boundCvtFunc = [&optVar](std::string const& valStr){optVar = Derived::template cvtFunc<Type>(valStr);};
        // pair the bound lambda with the optName so it can be called with a value later
    d_optNameToBoundCvtFunc[optName] = boundCvtFunc;
}

template <typename Derived>
void ArgsBase<Derived>::set(std::string const& optName, std::string const& valStr)
{
        // if the arg has ben registered, convert the valStr to a value
        // of <Type> and assign it with the bound function
    if (d_optNameToBoundCvtFunc.count(optName))
        d_optNameToBoundCvtFunc[optName](valStr);
    else
        throw ( std::string("Attempting to set unregistered arg: ") + optName);
}